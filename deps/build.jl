using CUDAapi

using Libdl


## API routines

# these routines are the bare minimum we need from the API during build;
# keep in sync with the actual implementations in src/

macro apicall(libpath, fn, types, args...)
    quote
        lib = Libdl.dlopen($(esc(libpath)))
        sym = Libdl.dlsym(lib, $(esc(fn)))

        ccall(sym, Cint, $(esc(types)), $(map(esc, args)...))
    end
end

function version(libpath)
    ref = Ref{Cint}()
    status = @apicall(libpath, :cuDriverGetVersion, (Ptr{Cint}, ), ref)
    @assert status == 0
    return VersionNumber(ref[] รท 1000, mod(ref[], 100) รท 10)
end

function init(libpath, flags=0)
    @apicall(libpath, :cuInit, (Cint, ), flags)
end


## main

const config_path = joinpath(@__DIR__, "ext.jl")
const previous_config_path = config_path * ".bak"

function write_ext(config, path)
    open(path, "w") do io
        println(io, "# autogenerated file, do not edit")
        for (key,val) in config
            println(io, "const $key = $(repr(val))")
        end
    end
end

function read_ext(path)
    config = Dict{Symbol,Any}()
    r = r"^const (\w+) = (.+)$"
    open(path, "r") do io
        for line in eachline(io)
            m = match(r, line)
            if m != nothing
                config[Symbol(m.captures[1])] = eval(Meta.parse(m.captures[2]))
            end
        end
    end
    return config
end

function build_error(reason)
    println("$reason.")
    exit(1)
end

function main()
    ispath(config_path) && mv(config_path, previous_config_path; force=true)
    config = Dict{Symbol,Any}(:configured => false)
    write_ext(config, config_path)


    ## discover stuff

    # NOTE: on macOS, the driver is part of the toolkit
    toolkit_dirs = find_toolkit()

    config[:libcuda_path] = find_cuda_library("cuda", toolkit_dirs)
    if config[:libcuda_path] == nothing
        build_error("Could not find CUDA driver library")
    end
    config[:libcuda_vendor] = "NVIDIA"

    # initializing the library isn't necessary, but flushes out errors that otherwise would
    # happen during `version` or, worse, at package load time.
    status = init(config[:libcuda_path])
    if status != 0
        # decode some common errors (as we haven't loaded errors.jl yet)
        if status == -1
            build_error("Building against CUDA driver stubs, which is not supported.")
        elseif status == 100
            build_error("Initializing CUDA driver failed: no CUDA hardware available (code 100).")
        elseif status == 999
            build_error("Initializing CUDA driver failed: unknown error (code 999).")
        else
            build_error("Initializing CUDA driver failed with code $status.")
        end
    end

    config[:libcuda_version] = version(config[:libcuda_path])

    config[:configured] = true


    ## (re)generate ext.jl

    if isfile(previous_config_path)
        previous_config = read_ext(previous_config_path)

        if config == previous_config
            mv(previous_config_path, config_path; force=true)
            return
        end
    end

    write_ext(config, config_path)

    return
end

main()
